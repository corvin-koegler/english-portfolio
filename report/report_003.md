## Abstract
## Introduction

Software development and construction share many parallels and have historically been treated mostly the same. This historically extends to the project lifecycles. In the early days of software developers had to write large amounts of their code on paper because computer time was scarce and machines where still slow. Just like construction the job of the architect and the construction worker (programmer) were separated because both jobs called for a different skillset. The project got constructed on paper iterated on by multiple experts in different phases and ultimately constructed with the difference being that one field worked with steel and concrete and the other with text inputs.

In construction one of the most popular design approaches is the waterfall concept where the project flows down the different steps and then ends in a maintenance loop. Until recently software had to be treated similar because once shipped updates where bound to significant effort. With the internet the need for fully thought out products in software mostly vanished reducing the time from the drawing board to the customer significantly. While software and construction still share similarities the field of software engineering has evolved in a different direction. With CICD it's becoming increasingly popular to develop the product with the customer, continuously iterating and refining it.

Companies picked up on this and largely switched to agile developments techniques that are specifically designed to accommodate the new dynamic style of development. It is now significantly cheaper to bring a product to the customer and is even more normal to find beta state applications that are intentionally rapidly developing and instable. Because of software frameworks and libraries most base functionality is ready for production reducing the need for writing new software to the unique aspects of the projects.

Somewhere in this transition the traditional visualization tools lost most of their relevance. It's a significant overhead to update a UML diagram every time 

## Traditional Visualizations
### UML Diagrams
### Flow Charts
### Gnatt Diagrams
## Modern Visualizations
### Code City
### gource.io
## Conclusion